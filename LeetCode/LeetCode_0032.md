# LeetCode_0032 最长有效括号

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:
```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```
示例 2:
```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

```

# 解答
定义 dp[i] 表示下标 i 字符结尾的最长有效括号的长度。我们将 dp 数组全部初始化为 0。显然有效的子串一定以 ‘）’结尾，音痴我们可以知道‘（’结尾的子串对应的 dp值必定为 0 ，我们只需要求解 ‘）’在 dp 数组中对应位置的值。

我们从前往后遍历字符串求解 dp 值，我们每两个字符检查一次：
1. s[i] == ')' 且 s[i-1] == '(',也就是字符串形如 ".....()",我们可以推出：
        **dp[i] = dp[i-2] + 2**
        我们可以进行这样的转移，是因为结束部分的 "()" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 22 。
        
2. s[i]=‘)’ 且 s[i−1]=‘)’，也就是字符串形如 “……))”，我们可以推出：
        如果 s[i−dp[i−1]−1]=‘(’，那么
        **dp[i] = dp[i-1] + dp[i-dp[i-1]-2]+2**
        



```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0,len = s.length();
        vector<int> dp(len,0);
        for(int i = 1;i < len;i++) {
            if(s[i] == ')') {
                if(s[i - 1] == '(') {
                    if(i >= 2) {
                        dp[i] = dp[i-2] + 2;
                    } else {
                        dp[i] = 2;
                    }
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    if((i - dp[i - 1]) >= 2) {
                         dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;
                    } else {
                        dp[i] = dp[i - 1] + 2;
                    }
                }
                maxans = max(maxans, dp[i]);
            }
        }
        return maxans;
    }
};
```