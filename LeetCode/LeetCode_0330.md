# LeetCode_0330 按要求补齐数组
给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

示例 1:
```
输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
```

示例 2:
```
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
```
示例 3:
```
输入: nums = [1,2,2], n = 5
输出: 0
```

# 解答

我们从左往右遍历数组，并且维护一个到当前为止最大可以到达的值。如果当前数组的值比这个最大值大，就说明我们无法合成这个值，需要补贴一个数，然后加上补贴的这个数更新为新的最大可能到达的值。以题目中的测试用例2（nums = [1, 5, 10], n = 20）为例来说明具体过程：

1. 初始状态：能够 cover 的是小于 1 的数，因此第一个遇到 1，正好可以 cover 下一个数，不需要补贴，这样我们可以更新最大可以 cover 的值为 1*2 = 2 以内的数（不包含2）。
2. 第二个数是 5，而我们现在能够 cover 的是小于 1 的数，因此需要补贴一个 2，此时更新 cover 的值为 2*2 = 4，即我们可以 cover 4 以内的数（不包含 4）；然后我们发现依然不能到达 5，所以需要在补贴一个 4，之后可以到达的数就是 8 之内的数了（不包含8）；再看数组 5，因为5已经在可以cover的范围之内了，而多了 5 之后，可以 cover 的最大值就变成了 8 + 5 = 13 之内的数了（不包含 13）；此时可以再遍历下一个数了。
3. 下一个数组值为 10，依然在我们可以 cover 的范围之内，因此不需要补贴，但是 cover 的值却可以更新到 13 + 10 = 23 > 20，因此就可以返回了。


任何时候都应满足区间 [1,x−1] 内的所有数字都被覆盖。令 x 的初始值为 1，数组下标 index 的初始值为 0，则初始状态下区间 [1,x−1] 为空区间，满足区间内的所有数字都被覆盖。进行如下操作。

* 如果 index 在数组 nums 的下标范围内且 nums[index] ≤ x，则将 nums[index] 的值加给 x，并将index 的值加 1。
    * 被覆盖的区间从 [1,x−1] 扩展到 [1,x+nums[index]−1]，对 x 的值更新以后，被覆盖的区间为 [1,x−1]。
* 否则，x 没有被覆盖，因此需要在数组中补充 x，然后将 x 的值乘以 2。
    * 在数组中补充 x 之后，被覆盖的区间从 [1,x-1] 扩展到 [1,2x−1]，对 x 的值更新以后，被覆盖的区间为 [1,x-1]。
* 重复上述操作，直到 x 的值大于 n。


```C++
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        int waterCount = 0;  
        int index = 0;  
        long long water = 1;  
        while (water <= n) {  
            if (index < nums.size() && nums[index] <= water) {  
                water += nums[index++];  
            } else {  
                water += water;  
                waterCount++;  
            }
        }  
        return waterCount;  
    }
};
```

* 时间复杂度：O(m + logn)。m 是 nums 的长度，n 是给定的正整数。
* 空间复杂度：O(1)